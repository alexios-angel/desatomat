#!/usr/bin/env python3

"""
Copyright (c) 2024 Alexios Angel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

VERSION="0.1.0"
AUTHORS=[
    {"name":"Alexios Angel", "email":"aangeletakis@gmail.com"},
]
HOMEPAGE="https://github.com/alexios-angel/desatomat"
ISSUES="https://github.com/alexios-angel/desatomat/issues"
LICENSE="MIT"

# Module lark needed to parse EDS file
from lark import Lark, Token, Transformer, Discard, Visitor, Tree
import argparse                 # Needed to handle cmd line arguments
import os                       # Needed for file handling
from io import TextIOWrapper    # Needed to provide type hint for argparse.Action
from pathlib import Path        # Needed for filenames in argparse
import re                       # Needed to validate cpp identifer names
from enum import Enum, auto     # Needed to enumerate rule_atom
import logging

logging_level=logging.INFO

class rule_enum(Enum):
    atom = 0
    terminal = auto()
    string = auto()
    non_terminal = auto()
    semantic_action = auto()
    epsilon = auto()

# Define the grammar
grammar = r"""
    start: (SPACES? (rule_statement | set_definition | comment)? WHITESPACES?)*

    comment: /#.*/

    rule_statement: NAME /(-?->)|(::=)|(:)/ rule_list 
    rule_list: rule ("|" rule)*
    rule: epsilon | ((NAME ":")? rule_content)
    rule_content: rule_atom ("," rule_atom)* ","?
    rule_atom: ATOM | terminal | string | non_terminal | semantic_action
    # Empty string can signify epsilon
    epsilon: (EPSILON_AT|EPSILON|)

    terminal: NAME | "*" NAME | NAME EPSILON_AT ATOM
    string: "\"" TEXT "\""
    TEXT: /((\\.)|[^"])+/
    non_terminal: "<" NAME ">"
    semantic_action: "[" NAME "]"

    set_definition: NAME "=" minus_sigma? "{" set_contents "}"
    minus_sigma: "sigma" "-"
    set_contents: ATOM ("," ATOM)* ","?
    
    NAME: /[a-zA-Z_0-9]+/
    EPSILON_AT: "@"
    EPSILON: "epsilon"
    ATOM: /\\?[^\s]/
    SPACES: /[ \t\f]+/
    WHITESPACES: /\s+/ 
    %ignore WHITESPACES
"""

class SpaceTransformer(Transformer):
    def WHITESPACES(self, tok: Token):
        return Discard
    def SPACES(self, tok: Token):
        return Discard

class RuleTransformer(Transformer):
    def rule_atom(self, tree: Tree):
        rule_atom = tree[0]
        if isinstance(rule_atom, Token):
            return {"value":rule_atom.value, "type":rule_enum.atom}
        else:
            type = getattr(rule_enum, rule_atom.data)
            value = rule_atom.children[0].value
            return {"value":value, "type":type}
    def rule(self, tok):
        rule_tok = tok[0]
        if rule_tok.data == "epsilon":
            return [{"value":"epsilon", "type":rule_enum.epsilon}]
        else:
            return rule_tok.children

class SetTransformer(Transformer):
    def set_contents(self, tree):
        # set_definition.children     -> NAME, minus_sigma, set_contents
        # set_definition.children[-1] -> set_contents
        # set_definition.set_contents.children -> ATOM, ATOM, ATOM, ...
        #   minus_sigma not guaranteed to be in set_definition's children.
        #   Anyway, CTRE does not use minus_sigma so we are not handling it
        ATOMS = tree

        # Turn Token('ATOM', CHAR) into a list of CHAR-s
        res = [token.value for token in ATOMS]

        # Ignore the '\' at the beginning of the string
        res = [token if token[0] != '\\' else token[-1] for token in res]

        # Convert list to string (easier to read for debugging)
        res = "".join(res)
        return res 

identifier_table={
    "nonterminal":{},
    "terminal":{
        'other':''
    }
}

class add_identifers(Visitor):
    def set_definition(self, tree):
        # minus_sigma not guaranteed to be in set_definition's children.
        # Anyway, CTRE does not use minus_sigma so we are not handling it
        NAME = tree.children[0]
        set_contents = tree.children[-1]

        # If set_definition has 3 children then minus_sigma is definately in it
        if len(tree.children) == 3:
            raise Exception("'sigma-' not supported in sets")

        identifier_table["terminal"][NAME.value] = set_contents
    def rule_statement(self, tree):
        NAME = tree.children[0]
        name = NAME.value
        rules = tree.children[-1].children
        nonterminal_table = identifier_table['nonterminal']
        if not name in nonterminal_table:
            nonterminal_table[name] = []

        nonterminal_table[name].append(rules)

class verify_identifiers(Visitor):
    def terminal(self, tree):
        # Terminal value
        tok = tree.children[0].value
        # For some reason ATOMS are being translated as terminals
        # Hack: Skip over single character ATOMS
        if len(tok) != 1:
            if not tok in identifier_table["terminal"]:
                raise Exception(f"Unknown identifier {tok}")
 
    def non_terminal(self, tree):
        pass

def is_accessible(path):
    return os.access(path, os.R_OK)

def is_accessible_file(filepath):
    """
    Check if a file exists and is readable.

    :param filepath: Path to the file.
    :return: True if the file exists and is readable, False otherwise.
    """
    return os.path.isfile(filepath) and is_accessible(filepath)

def is_accessible_dir(dirpath):
    """
    Check if a directory exists and is readable.

    :param filepath: Path to the directory.
    :return: True if the directory exists and is readable, False otherwise.
    """
    return os.path.isdir(dirpath) and is_accessible(dirpath)

# argparse action to validate file input
class ValidateFileExistsAction(argparse.Action):
    def __call__(self, parser:argparse.ArgumentParser, namespace, arg:TextIOWrapper, option_string=None):
        arg_value = arg.name
        if arg == '-' or is_accessible_file(arg_value):
            setattr(namespace, self.dest, arg)
        else:
            parser.error(f"The file {arg_value} does not exist or cannot be read.")

class ValidateFileOrDirectoryExistsAction(argparse.Action):
    def __call__(self, parser:argparse.ArgumentParser, namespace, arg:Path, option_string=None):
        if is_accessible_file(arg) or is_accessible_dir(arg):
            setattr(namespace, self.dest, arg)
        else:
            parser.error(f"The provided path {arg} does not exist or cannot be read.")

class ValidateCppIdentifierNameAction(argparse.Action):
    def __call__(self, parser:argparse.ArgumentParser, namespace, arg:str, option_string=None):
        if re.search(r"^[_a-zA-Z][_a-zA-Z0-9]*$", arg):
            setattr(namespace, self.dest, arg)
        else:
            parser.error(f"The provided name {arg} is not a valid C++ identifier name.")

logging_levels={
    "debug":"DEBUG",
    "info":"INFO",
    "warning":"WARNING",
    "error":"ERROR",
    "critical":"CRITICAL"
}
class SetLoggingLevelAction(argparse.Action):
    def __call__(self, parser:argparse.ArgumentParser, namespace, arg:str, option_string=None):
        if arg in logging_levels:
            setattr(namespace, self.dest, logging_levels[arg])
        else:
            parser.error("Invaild logging level specified.")

def parse_args():
    author_strings = [f"{author['name']} <{author['email']}>" for author in AUTHORS]
    author_string_spacing=' '*4
    author_string = f"\n{author_string_spacing}".join(author_strings)
    epilog=f"""
    This software was written by:

    {author_string_spacing}{author_string}

    Software homepage: {HOMEPAGE}
    Submit issues to: {ISSUES}
    This software is under the {LICENSE} license.
    """
    parser = argparse.ArgumentParser(description="Desatomat is a parser generator which outputs C++", 
                                     formatter_class=argparse.RawDescriptionHelpFormatter, 
                                     epilog=epilog)

    parser.add_argument('--log', '-l', action=SetLoggingLevelAction, help="Explicity set logging level")
    parser.add_argument('--quiet', '-q', action='store_true', default=False, help='Set logging level to quiet')
    parser.add_argument('--verbose', action='store_true', default=False, help='Set logging level to verbose')
    parser.add_argument('--version', '-v', action='store_true', default=False, help='Output version and exit')

    # Add flags with True as default. Ignored because they are the defualt,
    # we have to handle them becuase Compile Time Regular Expressions libary uses them
    parser.add_argument('--ll', action='store_true', default=True, help='LL1 flag, enabled regardless')
    parser.add_argument('--q', action='store_true', default=True, help='Q-grammer flag, enabled regardless')

     # Add standard arguments with defaults
    parser.add_argument('--input', type=argparse.FileType('r'), default='-', action=ValidateFileExistsAction, help='Input file path or "-" for stdin')
    parser.add_argument('--output', type=Path, default='.', action=ValidateFileOrDirectoryExistsAction, help='Output directory')
    parser.add_argument('--generator', type=str, default='cpp_ctll_v2', help='Generator to use')
    
    # Add configuration arguments
    parser.add_argument('--cfg:fname', "--fname", 
                        type=Path, 
                        default="grammer.hpp", 
                        help='Output filename')
    parser.add_argument('--cfg:namespace', "--namespace", 
                        type=str, 
                        default="Grammer", 
                        action=ValidateCppIdentifierNameAction, 
                        help='C++ namespace to put the grammer in')
    parser.add_argument('--cfg:guard', "--guard", 
                        type=str, 
                        action=ValidateCppIdentifierNameAction, 
                        help='C++ header guard name')
    parser.add_argument('--cfg:grammar_name', "--grammer_name", 
                        type=str, 
                        default="Grammer", 
                        action=ValidateCppIdentifierNameAction, 
                        help='C++ grammar struct name')

    # Parse known args
    args, remaining_args = parser.parse_known_args()
    
    for arg in remaining_args:
        if is_accessible_file(arg):
            remaining_args.remove(arg)
            remaining_args += [f"--input={arg}"]

    # Parse remaining args if necessary
    parser.parse_args(remaining_args, namespace=args)

    return args

if __name__ == "__main__":
    args = parse_args()

    if args.version:
        print(VERSION)
        exit(0)

    if args.log:
        logging_level = getattr(logging, args.log)
    elif args.quiet:
        logging_level = logging.ERROR
    elif args.verbose:
        logging_level = logging.DEBUG

    with args.input as input_file:
        input_data = input_file.read() 
 
    parser = Lark(grammar, start='start')
    tree = parser.parse(input_data)
    tree = (SpaceTransformer()*RuleTransformer()*SetTransformer()).transform(tree)
    (add_identifers()).visit(tree)
    (verify_identifiers()).visit(tree)