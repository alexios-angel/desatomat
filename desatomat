#!/usr/bin/env python3

"""
Copyright (c) 2024 Alexios Angel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

VERSION="0.1.0"
AUTHORS=[
    {"name":"Alexios Angel", "email":"aangeletakis@gmail.com"},
]
HOMEPAGE="https://github.com/alexios-angel/desatomat"
ISSUES="https://github.com/alexios-angel/desatomat/issues"
LICENSE="MIT"

# Module lark needed to parse EDS file
from lark import Lark, Token, Transformer, Discard, Visitor, Tree
import argparse                 # Needed to handle cmd line arguments
import os                       # Needed for file handling
from io import TextIOWrapper    # Needed to provide type hint for argparse.Action
from pathlib import Path        # Needed for filenames in argparse
import re                       # Needed to validate cpp identifer names
from enum import Enum, auto     # Needed to enumerate rule_atom
import logging                  # Needed to log to stdout
from sys import stdout          # Needed for logging
from pprint import pformat      # Needed for logging
from typing import List, Dict   # Needed to provide type hints to vscode
from unicodedata import name as unicode_name # Needed to covert characters into word form

logger = logging.getLogger(__name__)
logging_level=logging.INFO

class rule_enum(Enum):
    atom = 0
    terminal = auto()
    string = auto()
    non_terminal = auto()
    semantic_action = auto()
    epsilon = auto()

# Define the grammar
grammar = r"""
    start: (SPACES? (rule_statement | set_definition | comment)? WHITESPACES?)*

    comment: /#.*/

    rule_statement: NAME /(-?->)|(::=)|(:)/ rule_list 
    rule_list: rule ("|" rule)*
    rule: epsilon_empty | ((NAME ":")? rule_content)
    rule_content: rule_atom ("," rule_atom)* ","?
    rule_atom: epsilon | ATOM | terminal | string | non_terminal | semantic_action
    epsilon: (EPSILON_AT|EPSILON)
    # Empty rule can signify epsilon
    epsilon_empty:

    terminal: NAME | "*" NAME | NAME EPSILON_AT ATOM
    string: "\"" TEXT "\""
    TEXT: /((\\.)|[^"])+/
    non_terminal: "<" NAME ">"
    semantic_action: "[" NAME "]"

    set_definition: NAME "=" minus_sigma? "{" set_contents "}"
    minus_sigma: "sigma" "-"
    set_contents: ATOM ("," ATOM)* ","?
    
    NAME: /[a-zA-Z_0-9]+/
    EPSILON_AT: "@"
    EPSILON: "epsilon"
    ATOM: /\\?[^\s]/
    SPACES: /[ \t\f]+/
    WHITESPACES: /\s+/ 
    %ignore WHITESPACES
"""

class SpaceTransformer(Transformer):
    def WHITESPACES(self, tok: Token):
        return Discard
    def SPACES(self, tok: Token):
        return Discard

class RuleTransformer(Transformer):
    def rule_atom(self, tree: Tree):
        rule_atom = tree[0]
        if isinstance(rule_atom, Token):
            if rule_atom.type == 'ATOM':
                return {"value":rule_atom.value, "type":rule_enum.atom}
            else:
                # This *shouldn't* happen, but handling anyway
                raise Exception("Unknown rule_atom Token")
        else:
            type = getattr(rule_enum, rule_atom.data)
            value = rule_atom.children[0].value
            return {"value":value, "type":type}
    def rule(self, tok):
        rule_tok = tok[0]
        if rule_tok.data == "epsilon_empty":
            return [{"value":"epsilon", "type":rule_enum.epsilon}]
        else:
            return rule_tok.children

class SetTransformer(Transformer):
    def set_contents(self, tree):
        # set_definition.children     -> NAME, minus_sigma, set_contents
        # set_definition.children[-1] -> set_contents
        # set_definition.set_contents.children -> ATOM, ATOM, ATOM, ...
        #   minus_sigma not guaranteed to be in set_definition's children.
        #   Anyway, CTRE does not use minus_sigma so we are not handling it
        ATOMS = tree

        # Turn Token('ATOM', CHAR) into a list of CHAR-s
        res = [token.value for token in ATOMS]

        # Ignore the '\' at the beginning of the string
        res = [token if token[0] != '\\' else token[-1] for token in res]

        # Convert list to string (easier to read for debugging)
        res = "".join(res)
        return res 

identifier_table={
    "action":{},
    "nonterminal":{},
    "terminal":{
        'other':''
    }
}

class add_identifers(Visitor):
    def set_definition(self, tree):
        # minus_sigma not guaranteed to be in set_definition's children.
        # Anyway, CTRE does not use minus_sigma so we are not handling it
        NAME = tree.children[0]
        set_contents = tree.children[-1]

        # If set_definition has 3 children then minus_sigma is definately in it
        if len(tree.children) == 3:
            raise Exception("'sigma-' not supported in sets")

        identifier_table["terminal"][NAME.value] = set_contents
    def rule_statement(self, tree):
        NAME = tree.children[0]
        name = NAME.value

        rules = tree.children[-1].children
        nonterminal_table = identifier_table['nonterminal']
        if not name in nonterminal_table:
            nonterminal_table[name] = []

        nonterminal_table[name].append(rules)

def add_semantic_action_identifiers(table):
    actions = {}
    for x in table['nonterminal'].values():
        for y in x:
            for z in y:
                for w in z:
                    if w['type'] == rule_enum.semantic_action:
                        actions[w['value']] = ''
    table['action'] = actions.keys()

def verify_identifiers(table):
    pass

def table_to_constexpr_cpp(table:Dict[str, List[List[List[Dict[str, rule_enum]]]]], args):
    indentation = ' '*4
    rule_strings = []
    for rule_name, rule_content in table['nonterminal'].items():
        for rule in rule_content:
            rule_ll1_term = "ctll::term<' '>"
            #print(pformat(rule))
            rule_strings.append(f"static constexpr auto rule({rule_name}, {rule_ll1_term}) -> ctll::push<ctll::anything>;")

    ret = \
f"""
#ifndef {args.guard}
#define {args.guard}

// THIS FILE WAS GENERATED BY DESATOMAT TOOL, DO NOT MODIFY THIS FILE

#include "../ctll/grammars.hpp"

namespace {args.namespace} {{
    
struct {args.grammer_name} {{

{indentation}// NONTERMINALS:
{indentation}{f"\n{indentation}".join([f"struct {nonterminal} {{}};" for nonterminal in table['nonterminal'].keys()])}

{indentation}// 'action' types:
{indentation}{f"\n{indentation}".join([f"struct {action}: ctll::action {{}};" for action in table['action']])}

{indentation}// (q)LL1 function:
{indentation}{f"\n{indentation}".join(rule_strings)}

}}; // struct {args.grammer_name}

}} // namespace {args.namespace}

#endif // {args.guard}
"""
    return ret.strip()

def is_accessible(path):
    return os.access(path, os.R_OK)

def is_accessible_file(filepath):
    """
    Check if a file exists and is readable.

    :param filepath: Path to the file.
    :return: True if the file exists and is readable, False otherwise.
    """
    return os.path.isfile(filepath) and is_accessible(filepath)

def is_accessible_dir(dirpath):
    """
    Check if a directory exists and is readable.

    :param filepath: Path to the directory.
    :return: True if the directory exists and is readable, False otherwise.
    """
    return os.path.isdir(dirpath) and is_accessible(dirpath)

# argparse action to validate file input
class ValidateFileExistsAction(argparse.Action):
    def __call__(self, parser:argparse.ArgumentParser, namespace, arg:TextIOWrapper, option_string=None):
        arg_value = arg.name
        if arg == '-' or is_accessible_file(arg_value):
            setattr(namespace, self.dest, arg)
        else:
            parser.error(f"The file {arg_value} does not exist or cannot be read.")

class ValidateFileOrDirectoryExistsAction(argparse.Action):
    def __call__(self, parser:argparse.ArgumentParser, namespace, arg:Path, option_string=None):
        if is_accessible_file(arg) or is_accessible_dir(arg):
            setattr(namespace, self.dest, arg)
        else:
            parser.error(f"The provided path {arg} does not exist or cannot be read.")

class ValidateCppIdentifierNameAction(argparse.Action):
    def __call__(self, parser:argparse.ArgumentParser, namespace, arg:str, option_string=None):
        if re.search(r"^[_a-zA-Z][_a-zA-Z0-9]*$", arg):
            setattr(namespace, self.dest, arg)
        else:
            parser.error(f"The provided name {arg} is not a valid C++ identifier name.")

logging_levels={
    "debug":"DEBUG",
    "info":"INFO",
    "warn":"WARNING",
    "error":"ERROR",
    "critical":"CRITICAL"
}
class SetLoggingLevelAction(argparse.Action):
    def __call__(self, parser:argparse.ArgumentParser, namespace, arg:str, option_string=None):
        if arg in logging_levels:
            setattr(namespace, self.dest, logging_levels[arg])
        else:
            parser.error("Invaild logging level specified.")

def parse_args():
    author_strings = [f"{author['name']} <{author['email']}>" for author in AUTHORS]
    author_string_spacing=' '*4
    author_string = f"\n{author_string_spacing}".join(author_strings)
    epilog=f"""
    This software was written by:

    {author_string_spacing}{author_string}

    Software homepage: {HOMEPAGE}
    Submit issues to: {ISSUES}
    This software is under the {LICENSE} license.
    """
    parser = argparse.ArgumentParser(description="Desatomat is a parser generator which outputs C++", 
                                     formatter_class=argparse.RawDescriptionHelpFormatter, 
                                     epilog=epilog)

    parser.add_argument('--log', '-l', action=SetLoggingLevelAction, help="Explicity set logging level")
    parser.add_argument('--quiet', '-q', action='store_true', default=False, help='Set logging level to quiet')
    parser.add_argument('--verbose', action='store_true', default=False, help='Set logging level to verbose')
    parser.add_argument('--version', '-v', action='store_true', default=False, help='Output version and exit')

    # Add flags with True as default. Ignored because they are the defualt,
    # we have to handle them becuase Compile Time Regular Expressions libary uses them
    parser.add_argument('--ll', action='store_true', default=True, help='LL1 flag, enabled regardless')
    parser.add_argument('--q', action='store_true', default=True, help='Q-grammer flag, enabled regardless')

     # Add standard arguments with defaults
    parser.add_argument('--input', type=argparse.FileType('r'), action=ValidateFileExistsAction, help='Input file path or "-" for stdin')
    parser.add_argument('--output', type=Path, default='.', action=ValidateFileOrDirectoryExistsAction, help='Output directory')
    parser.add_argument('--generator', type=str, default='cpp_ctll_v2', help='Generator to use')
    
    # Add configuration arguments
    parser.add_argument("--fname", '--cfg:fname',
                        type=Path, 
                        default="grammer.hpp", 
                        help='Output filename')
    parser.add_argument("--namespace", '--cfg:namespace',
                        type=str, 
                        default="Grammer", 
                        action=ValidateCppIdentifierNameAction, 
                        help='C++ namespace to put the grammer in')
    parser.add_argument("--guard", '--cfg:guard',
                        type=str,
                        default="GRAMMER_HPP",
                        action=ValidateCppIdentifierNameAction, 
                        help='C++ header guard name')
    parser.add_argument("--grammer_name", '--cfg:grammar_name', 
                        type=str, 
                        default="Grammer", 
                        action=ValidateCppIdentifierNameAction, 
                        help='C++ grammar struct name')

    # Parse known args
    args, remaining_args = parser.parse_known_args()
    
    for arg in remaining_args:
        if is_accessible_file(arg):
            remaining_args.remove(arg)
            remaining_args += [f"--input={arg}"]

    # Parse remaining args if necessary
    parser.parse_args(remaining_args, namespace=args)

    return args

if __name__ == "__main__":
    args = parse_args()

    if args.version:
        print(VERSION)
        exit(0)

    if args.log:
        logging_level = getattr(logging, args.log)
    elif args.quiet:
        logging_level = logging.ERROR
    elif args.verbose:
        logging_level = logging.DEBUG

    logging_format = '%(message)s'
    logging.basicConfig(stream=stdout, format=logging_format, level=logging_level)

    logger.debug(args)

    with args.input as input_file:
        input_data = input_file.read() 
    
    parser = Lark(grammar, start='start')
    
    logger.info(f"Parsing EDS file {args.input.name}")
    tree = parser.parse(input_data)
    
    logger.info("Transforming parse tree")
    tree = (SpaceTransformer()*RuleTransformer()*SetTransformer()).transform(tree)

    logger.info("Adding identifiers to identifer table")
    (add_identifers()).visit(tree)
    add_semantic_action_identifiers(identifier_table)

    logger.debug("Identifer Table:")
    logger.debug(pformat(identifier_table))

    logger.info("Verifying that add identifers have been defined")
    verify_identifiers(identifier_table)

    logger.info("Converting table into cpp")
    
    constexpr_cpp = table_to_constexpr_cpp(identifier_table, args)
    
    if os.path.exists(args.fname):
        mode = 'w'
    else:
        mode = 'x'

    with open(args.fname, mode) as f:
        f.write(constexpr_cpp)