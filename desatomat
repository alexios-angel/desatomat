#!/usr/bin/env python3

"""
Copyright (c) 2024 Alexios Angel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

VERSION="0.1.0"
AUTHORS=[
    {"name":"Alexios Angel", "email":"aangeletakis@gmail.com"},
]
HOMEPAGE="https://github.com/alexios-angel/desatomat"
ISSUES="https://github.com/alexios-angel/desatomat/issues"
LICENSE="MIT"

# Module lark needed to parse EDS file
from lark import Lark, Token, Transformer, Discard, Visitor, Tree
import argparse                 # Needed to handle cmd line arguments
import os                       # Needed for file handling
from io import TextIOWrapper    # Needed to provide type hint for argparse.Action
from pathlib import Path        # Needed for filenames in argparse
import re                       # Needed to validate cpp identifer names
from enum import Enum, auto     # Needed to enumerate rule_atom
import logging                  # Needed to log to stdout
from sys import stdout          # Needed for logging
from pprint import pformat      # Needed for logging
from typing import List, Dict, Optional, Any # Needed to provide type hints to vscode
from unicodedata import name as unicode_name # Needed to covert characters into word form
from collections import UserDict # For multidict

logging.captureWarnings(True)
logger = logging.getLogger(__name__)
logging_level=logging.INFO

# Further down we use getattr(x,y)
# Some of the types in here need to corrospond with the rules names
# in the grammer in order to use getattr
class desatomat_type(Enum):
    atom = 0
    terminal = auto()
    string = auto()
    non_terminal = auto()
    semantic_action = auto()
    epsilon = auto()
    positive_set = auto()
    negitive_set = auto()
    NUM_OF_ENUMS = auto()

class Symbol:
    def __init__(self, value, symbol_type):
        self.value = value
        self.type = symbol_type

    def __hash__(self):
        if isinstance(self.value, set):
            return hash((frozenset(self.value), self.type))
        elif isinstance(self.value, list):
            # Cast the list to a tuple to be able to hash
            return hash((tuple(self.value), self.type))
        elif isinstance(self.value, dict):
            return hash(frozenset(self.value.items()))
        return hash((self.value, self.type))

    def __eq__(self, other):
        if isinstance(other, Symbol):
            return self.value == other.value and self.type == other.type
        return False

    def __repr__(self):
        if isinstance(self.value, str):
            return f"Symbol('{self.value}', {self.type})"
        else:
            return f"Symbol({self.value}, {self.type})"
    
    def is_non_terminal(self):
        return self.type == desatomat_type.non_terminal

    def is_semantic_action(self):
        return self.type == desatomat_type.semantic_action

    def is_terminal(self):
        return \
            self.is_string() or \
            self.is_atom() or \
            self.is_set() or \
            self.type == desatomat_type.terminal
    
    def is_positive_set(self):
        return self.type == desatomat_type.positive_set

    def is_negitive_set(self):
        return self.type == desatomat_type.negitive_set

    def is_set(self):
        return self.is_positive_set() or self.is_negitive_set()

    def is_atom(self)
        return self.type == desatomat_type.atom

    def is_string(self):
        return self.type == desatomat_type.string

# Define the grammar
grammar = r"""
    start: (SPACES? (rule_statement | set_definition | comment)? WHITESPACES?)*

    comment: /#.*/

    rule_statement: SINGLE_NAME /(-?->)|(::=)|(:)/ rule_list 
    rule_list: rule ("|" rule)*
    rule: epsilon_empty | ((SINGLE_NAME ":")? rule_content)
    rule_content: rule_atom ("," rule_atom)* ","?
    rule_atom: epsilon | atom | terminal | string | non_terminal | semantic_action
    epsilon: (EPSILON_AT|EPSILON)
    # Empty rule can signify epsilon
    epsilon_empty:

    terminal: NAME | "*" NAME | NAME EPSILON_AT ATOM
    string: "\"" TEXT "\""
    atom: ATOM
    TEXT: /((\\.)|[^"])+/
    non_terminal: "<" NAME ">"
    semantic_action: "[" NAME "]"

    set_definition: NAME "=" minus_sigma? "{" set_contents "}"
    minus_sigma: "sigma" "-"
    set_contents: ATOM ("," ATOM)* ","?
    
    SINGLE_NAME: /[a-zA-Z_][a-zA-Z_0-9]*/
    NAME: /[a-zA-Z][a-zA-Z_0-9]+/
    EPSILON_AT: /(?<!\\)@/
    EPSILON: "epsilon"
    ATOM: /\\?[^\s]/
    SPACES: /[ \t\f]+/
    WHITESPACES: /\s+/ 
    %ignore WHITESPACES
"""

def unescape_character(char:str):
    if len(char) > 2:
        raise Exception('Character length greater than 2')
    if char[0] == '\\': 
        res_char = char.encode('latin-1', 'backslashreplace').decode('unicode-escape')
        # The encoder will not decode regualar characters.
        # If it doesn't the length will be 2
        if len(res_char) == 2:
            return res_char[-1]
        else:
            return res_char
    else:
        return char

class SpaceTransformer(Transformer):
    def WHITESPACES(self, tok: Token):
        return Discard
    def SPACES(self, tok: Token):
        return Discard

class RuleTransformer(Transformer):
    def rule_atom(self, tree: Tree):
        rule_atom = tree[0]
        value = rule_atom.children[0].value
        if rule_atom.data == "atom":
            value = unescape_character(value)
        type = getattr(desatomat_type, rule_atom.data)
        return Symbol(value, type)
    def rule(self, tok):
        rule_tok = tok[0]
        if rule_tok.data == "epsilon_empty":
            return [Symbol("epsilon", desatomat_type.epsilon)]
        else:
            return rule_tok.children

class SetTransformer(Transformer):
    def set_contents(self, tree):
        # set_definition.children     -> NAME, minus_sigma, set_contents
        # set_definition.children[-1] -> set_contents
        # set_definition.set_contents.children -> ATOM, ATOM, ATOM, ...
        #   minus_sigma not guaranteed to be in set_definition's children.
        #   Anyway, CTRE does not use minus_sigma so we are not handling it
        ATOMS = tree

        # Turn Token('ATOM', CHAR) into a list of CHAR-s
        res = [token.value for token in ATOMS]

        # Ignore the '\' at the beginning of the string
        res = [unescape_character(token) for token in res]

        # Make sure elements are not repeated
        res = set(res)
        
        return res 

identifier_graph={
    "nonterminal":{},
    "terminal":{}
}

identifier_table={
    "action":set(),
    "nonterminal":{},
    "terminal":{
        'other':Symbol([], desatomat_type.negitive_set)
    }
}

class add_identifers(Visitor):
    def set_definition(self, tree):
        # minus_sigma not guaranteed to be in set_definition's children.
        # Anyway, CTRE does not use minus_sigma so we are not handling it
        NAME = tree.children[0]
        set_contents = tree.children[-1]

        # If set_definition has 3 children then minus_sigma is definately in it
        set_type = desatomat_type.positive_set
        if len(tree.children) == 3:
            set_type = desatomat_type.negitive_set

        identifier_table["terminal"][NAME.value] = Symbol(set_contents, set_type)
    def rule_statement(self, tree):
        NAME = tree.children[0]
        name = NAME.value

        rules = tree.children[-1].children
        nonterminal_table = identifier_table['nonterminal']
        if not name in nonterminal_table:
            nonterminal_table[name] = []

        nonterminal_table[name]+=rules

def make_graph(id_graph, id_table):
    # Iterate over ["terminal", "nonterminal"]
    for id_type in ["terminal", "nonterminal"]:
        for name, content in id_table[id_type].items():
            id_graph[id_type][name] = {"name":name, "content":content, "visited":False}
    """
    for terminal_dict in id_graph["nonterminal"].values():
        for rule_index, rule in enumerate(terminal_dict['value']):
            for atom_index, atom in enumerate(rule):
                match atom['type']:
                    case desatomat_type.terminal:
                        id_graph['nonterminal'][terminal_dict['name']]['content'][rule_index][atom_index] = id_graph['terminal'][atom['value']]
                    case desatomat_type.non_terminal:
                        id_graph['nonterminal'][terminal_dict['name']]['content'][rule_index][atom_index] = id_graph['nonterminal'][atom['value']]

    """

def add_semantic_action_identifiers(table):
    actions = set()
    for x in table['nonterminal'].values():
        for z in x:
            for symbol in z:
                if symbol.is_semantic_action():
                    actions.add(symbol.value)
    table['action'] = actions

def break_strings(table):
    for nonterminal_name, nonterminal in table['nonterminal'].items():
        for rule_index, rule in list(enumerate(nonterminal)):
            for item_index, item in list(enumerate(rule)):
                if item.is_string():
                    string = item.value
                    rule_table = table['nonterminal'][nonterminal_name][rule_index]
                    rule_table.pop(item_index)
                    for c in reversed(string):
                        rule_table.insert(item_index, Symbol(c, desatomat_type.atom))

def get_rule_name(items: Dict[str, str]):
    item_type = items['type']
    item_value = items['value']
    if item_type == desatomat_type.atom:
        if re.search(r"^[a-zA-Z0-9]$", item_value):
            character_name = item_value
        else:
            character_name = unicode_name(item_value).replace(' ', '_').lower()
        return f"_term_{character_name}"
    if item_type == desatomat_type.terminal:
        return f"_term_{item_value}"
    else:
        return f"_rule_{item_value}"

def verify_identifiers(table):
    ids = {
        "nonterminal": set(),
        "terminal": set()
    }
    for x in table['nonterminal'].values():
        for z in x:
            for symbol in z:
                if symbol.is_non_terminal():
                    ids['nonterminal'].add(symbol.value)
                elif symbol.is_terminal():
                    ids['terminal'].add(symbol.value)

    nonterminal_ids = ids['nonterminal']
    defined_nonterminal_ids = set(table['nonterminal'].keys())
    remaining_nonterminal_ids = nonterminal_ids - defined_nonterminal_ids
    if len(remaining_nonterminal_ids) != 0:
        raise Exception(f'Unknown nonterminal(s): {', '.join(remaining_nonterminal_ids)}')
    
    terminal_ids = ids['terminal']
    defined_terminal_ids = set(table['terminal'].keys())
    remaining_terminal_ids = terminal_ids - defined_terminal_ids
    if len(remaining_terminal_ids) != 0:
        raise Exception(f'Unknown terminal(s): {', '.join(remaining_terminal_ids)}')

def table_to_constexpr_cpp(table:Dict[str, List[List[List[Dict[str, desatomat_type]]]]], args):
    indentation = ' '*4
    terminal_strings = []
    for terminal_name, terminal in table['terminal'].items():
        res = ""
        type_map = {desatomat_type.negitive_set:"neg_set", desatomat_type.positive_set:"set"}
        terminal_type_str = ""
        if len(terminal['value']) == 1 and not terminal['type'] == desatomat_type.negitive_set:
            terminal_type_str = "term"
        else:
            terminal_type_str = type_map[terminal['type']]
        res = f"using {terminal_name} = ctll::{terminal_type_str}<'{"', '".join(terminal['value'])}'>;"
        terminal_strings.append(res)
    rule_strings = []
    for rule_name, rule_content in table['nonterminal'].items():
        for rule in rule_content:
            rule_ll1_term = "ctll::term<' '>"
            #print(pformat(rule))
            rule_strings.append(f"static constexpr auto rule({rule_name}, {rule_ll1_term}) -> ctll::push<ctll::anything>;")

    ret = \
f"""
#ifndef {args.guard}
#define {args.guard}

// THIS FILE WAS GENERATED BY DESATOMAT TOOL, DO NOT MODIFY THIS FILE

#include "../ctll/grammars.hpp"

namespace {args.namespace} {{
    
struct {args.grammer_name} {{

{indentation}// NONTERMINALS:
{indentation}{f"\n{indentation}".join([f"struct {nonterminal} {{}};" for nonterminal in table['nonterminal'].keys()])}

{indentation}// 'action' types:
{indentation}{f"\n{indentation}".join([f"struct {action}: ctll::action {{}};" for action in table['action']])}

{indentation}// 'terminal' types:
{indentation}namespace terminal {{
{indentation*2}{f"\n{indentation*2}".join(terminal_strings)}
{indentation}}} // namespace terminal

{indentation}// (q)LL1 function:
{indentation}{f"\n{indentation}".join(rule_strings)}

}}; // struct {args.grammer_name}

}} // namespace {args.namespace}

#endif // {args.guard}
"""
    return ret.strip()

def is_accessible(path):
    return os.access(path, os.R_OK)

def is_accessible_file(filepath):
    """
    Check if a file exists and is readable.

    :param filepath: Path to the file.
    :return: True if the file exists and is readable, False otherwise.
    """
    return os.path.isfile(filepath) and is_accessible(filepath)

def is_accessible_dir(dirpath):
    """
    Check if a directory exists and is readable.

    :param filepath: Path to the directory.
    :return: True if the directory exists and is readable, False otherwise.
    """
    return os.path.isdir(dirpath) and is_accessible(dirpath)

# argparse action to validate file input
class ValidateFileExistsAction(argparse.Action):
    def __call__(self, parser:argparse.ArgumentParser, namespace, arg:TextIOWrapper, option_string=None):
        arg_value = arg.name
        if arg == '-' or is_accessible_file(arg_value):
            setattr(namespace, self.dest, arg)
        else:
            parser.error(f"The file {arg_value} does not exist or cannot be read.")

class ValidateFileOrDirectoryExistsAction(argparse.Action):
    def __call__(self, parser:argparse.ArgumentParser, namespace, arg:Path, option_string=None):
        if is_accessible_file(arg) or is_accessible_dir(arg):
            setattr(namespace, self.dest, arg)
        else:
            parser.error(f"The provided path {arg} does not exist or cannot be read.")

class ValidateCppIdentifierNameAction(argparse.Action):
    def __call__(self, parser:argparse.ArgumentParser, namespace, arg:str, option_string=None):
        if re.search(r"^[_a-zA-Z][_a-zA-Z0-9]*$", arg):
            setattr(namespace, self.dest, arg)
        else:
            parser.error(f"The provided name {arg} is not a valid C++ identifier name.")

logging_levels={
    "debug":"DEBUG",
    "info":"INFO",
    "warn":"WARNING",
    "error":"ERROR",
    "critical":"CRITICAL"
}
class SetLoggingLevelAction(argparse.Action):
    def __call__(self, parser:argparse.ArgumentParser, namespace, arg:str, option_string=None):
        if arg in logging_levels:
            setattr(namespace, self.dest, logging_levels[arg])
        else:
            parser.error("Invaild logging level specified.")

def parse_args():
    """
    Function that handles argparse

    :return: argparse namespace
    """
    author_strings = [f"{author['name']} <{author['email']}>" for author in AUTHORS]
    author_string_spacing=' '*4
    author_string = f"\n{author_string_spacing}".join(author_strings)
    epilog=f"""
    This software was written by:

    {author_string_spacing}{author_string}

    Software homepage: {HOMEPAGE}
    Submit issues to: {ISSUES}
    This software is under the {LICENSE} license.
    """
    parser = argparse.ArgumentParser(description="Desatomat is a parser generator which outputs C++", 
                                     formatter_class=argparse.RawDescriptionHelpFormatter, 
                                     epilog=epilog)

    parser.add_argument('--log', '-l', action=SetLoggingLevelAction, help="Explicity set logging level")
    parser.add_argument('--quiet', '-q', action='store_true', default=False, help='Set logging level to quiet')
    parser.add_argument('--verbose', action='store_true', default=False, help='Set logging level to verbose')
    parser.add_argument('--version', '-v', action='store_true', default=False, help='Output version and exit')

    # Add flags with True as default. Ignored because they are the defualt,
    # we have to handle them becuase Compile Time Regular Expressions libary uses them
    parser.add_argument('--ll', action='store_true', default=True, help='LL1 flag, enabled regardless')
    parser.add_argument('--q', action='store_true', default=True, help='Q-grammer flag, enabled regardless')

     # Add standard arguments with defaults
    parser.add_argument('--input', type=argparse.FileType('r'), action=ValidateFileExistsAction, help='Input file path or "-" for stdin')
    parser.add_argument('--output', type=Path, default='.', action=ValidateFileOrDirectoryExistsAction, help='Output directory')
    parser.add_argument('--generator', type=str, default='cpp_ctll_v2', help='Generator to use')
    
    # Add configuration arguments
    parser.add_argument("--fname", '--cfg:fname',
                        type=Path, 
                        default="grammer.hpp", 
                        help='Output filename')
    parser.add_argument("--namespace", '--cfg:namespace',
                        type=str, 
                        default="Grammer", 
                        action=ValidateCppIdentifierNameAction, 
                        help='C++ namespace to put the grammer in')
    parser.add_argument("--guard", '--cfg:guard',
                        type=str,
                        default="GRAMMER_HPP",
                        action=ValidateCppIdentifierNameAction, 
                        help='C++ header guard name')
    parser.add_argument("--grammer_name", '--cfg:grammar_name', 
                        type=str, 
                        default="Grammer", 
                        action=ValidateCppIdentifierNameAction, 
                        help='C++ grammar struct name')

    # Parse known args
    args, remaining_args = parser.parse_known_args()
    
    for arg in remaining_args:
        if os.path.is_file(arg):
            remaining_args.remove(arg)
            remaining_args += [f"--input={arg}"]

    # Parse remaining args if necessary
    parser.parse_args(remaining_args, namespace=args)

    return args

def main():
    args = parse_args()

    if args.version:
        print(VERSION)
        exit(0)

    if args.log:
        logging_level = getattr(logging, args.log)
    elif args.quiet:
        logging_level = logging.ERROR
    elif args.verbose:
        logging_level = logging.DEBUG

    logging_format = '%(message)s'
    logging.basicConfig(stream=stdout, format=logging_format, level=logging_level)

    logger.debug(args)

    with args.input as input_file:
        input_data = input_file.read() 
    
    parser = Lark(grammar, start='start')
    
    logger.info(f"Parsing EDS file {args.input.name}")
    tree = parser.parse(input_data)
    
    logger.info("Transforming parse tree")
    # 1. Remove whitespace tokens
    # 2. Transform rules into dictionary {"value":value, "type":type}
    # 3. Transform set contents into a list [1,2,3]
    tree = (SpaceTransformer()*RuleTransformer()*SetTransformer()).transform(tree)

    logger.info("Adding identifiers to identifer table")
    (add_identifers()).visit(tree)
    add_semantic_action_identifiers(identifier_table)

    logger.debug("Identifer Table:")
    logger.debug(pformat(identifier_table))

    logger.info("Checking identifers")
    verify_identifiers(identifier_table)
    logger.info("Identifers have been checked and all identifiers have been defined")

    logger.info("Turning strings into individual atoms")
    # Turn "string" into atoms: "abc" -> a,b,c
    break_strings(identifier_table)

    logger.info("Making graph")
    make_graph(identifier_graph, identifier_table)

    # Cannot use (pretty) print as it will take forever
    #logger.debug(identifier_graph)
    """
    logger.info("Converting table into cpp")
    
    constexpr_cpp = table_to_constexpr_cpp(identifier_table, args)
    
    if os.path.exists(args.fname):
        mode = 'w'
    else:
        mode = 'x'

    with open(args.fname, mode) as f:
        f.write(constexpr_cpp)
    """

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logger.exception("%s", repr(e))